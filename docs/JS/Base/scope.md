# Base_作用域 #

## 定义

在代码运行时，某些变量的可被访问范围

变量在作用域内不会被外泄和暴露，不会污染到外面的变量

**注意**：

作用域是分层的，内层作用域可以访问外层作用域的变量，反之则不行

## 作用

> 最大的用处就是隔离变量，不同作用域下同名变量不会有冲突

## 分类

| 类型       | 有效范围           |
| ---------- | ------------------ |
| 全局作用域 | 全局范围内         |
| 函数作用域 | 当前函数           |
| 块级作用域 | 当前块（let,const) |

### 全局作用域

> 在代码中任何地方都能访问到的对象拥有全局作用域

1. 最外层函数 和在最外层函数外面定义的变量拥有全局作用域

2. 所有末定义直接赋值的变量自动声明为拥有全局作用域

   ```javascript
   function outFun2() {
       variable = "未定义直接赋值的变量";
       var inVariable2 = "内层变量2";// 函数作用域
   }
   outFun2();//要先执行这个函数，否则根本不知道里面是啥
   console.log(variable); //未定义直接赋值的变量
   console.log(inVariable2); //inVariable2 is not defined
   ```

   

3. 所有 window 对象的属性拥有全局作用域

   #### 弊端

   有可能造成命名冲突

   #### 解决

   ES6之前如jQ用立即执行函数(function(){})()
   ES6用let / const

### 函数作用域

> 声明在函数内部的变量，和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部。

值得注意的是：

块语句（大括号“｛｝”中间的语句），如 if 和 switch 条件语句或 for 和 while 循环语句，不像函数，它们不会创建一个新的作用域。在块语句中定义的变量将保留在它们已经存在的作用域中。

```js
if (true) {
    // 'if' 条件语句块不会创建一个新的作用域
    var name = 'Hammad'; // name 依然在全局作用域中
}
console.log(name); // logs 'Hammad'
```



### 块级作用域

> 作用范围在一个代码块（由一对花括号包裹）内部

用let/const 声明的变量都会形成块级作用域，有以下特性：

1. 声明变量不会提升到代码块顶部

2. 禁止重复声明
  #### 为什么需要块级作用域
1. 内层变量可能会覆盖外层变量。
```
var tmp = new Date();

function f() {
  console.log(tmp);
  if (false) {
    var tmp = 'hello world';
  }
}

f(); // undefined
```
2. 用来计数的循环变量泄露为全局变量。
```
var s = 'hello';

for (var i = 0; i < s.length; i++) {
  console.log(s[i]);
}

console.log(i); // 5
```
>块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要了

>块级作用域内部，优先使用函数表达式,而不是函数声明，因为函数声明存在提升问题
   #### 使用场景

   在循环语句中，记录当前索引,用var永远打印出3，使用let可以依次打出123

   ```html
   <button>测试1</button>
   <button>测试2</button>
   <button>测试3</button>
   <script type="text/javascript">
      var btns = document.getElementsByTagName('button')
       for (var i = 0; i < btns.length; i++) {
         btns[i].onclick = function () {
           console.log('第' + (i + 1) + '个')
         }
       }
   </script>
   ```



# 作用域链

## 前置概念

**自由变量:**

> 当前作用域没有定义的变量，这成为自由变量

## 定义

> 自由变量会向 **定义时的父级作用域** 寻找定义，如果父级也没有找到，就会一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是 作用域链

**注意**

```js
var x = 10
function fn() {
  console.log(x)
}
function show(f) {
  var x = 20
  (function() {
    f() //10，而不是20
  })()
}
show(fn)
```

```js
var a = 10
function fn() {
  var b = 20
  function bar() {
    console.log(a + b) //30
  }
  return bar
}
var x = fn(),
  b = 200
x() //bar()
```



# 作用域与执行上下文

JavaScript属于解释型语言，JavaScript的执行分为：解释和执行两个阶段,这两个阶段所做的事并不一样：

## 解释阶段：

词法分析
语法分析
作用域规则确定

## 执行阶段：

创建执行上下文
执行函数代码
垃圾回收

作用域在函数定义时确定，作用域访问的变量是编写代码的结构确定的

执行上下文是函数执行之前创建的，this的指向是执行时确定的。

## 区别

1. 执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变。

2. 一个作用域下可能包含若干个上下文环境。有可能从来没有过上下文环境（函数从来就没有被调用过）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了；有可能同时存在一个或多个（闭包）。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。

[原文浪里行舟](https://segmentfault.com/a/1190000018513150)






