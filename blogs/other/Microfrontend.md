---
title: 微前端
data: 2020-07-26
tags:
 - 微前端
categories: 
 - 其他
---

[原文出处](https://baijiahao.baidu.com/s?id=1638313846156942854&amp;wfr=spider&amp;for=pc)

## 是什么:eye_speech_bubble:

它正是借鉴微服务的概念来应用在前端上，将一个巨大的前端工程拆分成一个的小工程，这些小工程具备独立的开发和运行能力，而整个系统就由这些小工程协同合作。

## 为什么:sparkler:

### 解决什么问题

::: tip

**遗留系统迁移**。

解决遗留系统，才是人们采用微前端方案最重要的原因。

**聚合前端应用**。

微服务架构，可以解耦后端服务间依赖。而微前端，则关注于聚合前端应用。

**热闹驱动开发**。

新的技术，既然很热闹，那么就学吧。微前端的实现，意味着对前端应用的拆分。拆分应用的目的，并不只是为了架构上好看，还为了提升开发效率。

:::

### 优点:slightly_smiling_face:

::: warning

**应用自治**。

只需要遵循统一的接口规范或者框架，以便于系统集成到一起，相互之间是不存在依赖关系的。

**单一职责**。

每个前端应用可以只关注于自己所需要完成的功能。

**技术栈无关**。

你可以使用 Angular 的同时，又可以使用 React 和 Vue

:::

### 缺点:cry:

::: danger

应用的拆分基础依赖于基础设施的构建，一旦大量应用依赖于同一基础设施，那么维护变成了一个挑战。拆分的粒度越小，便意味着架构变得复杂、维护成本变高。技术栈一旦多样化，便意味着技术栈混乱

:::

## 怎么做:rainbow:

### 架构模式

基座模式：

:::tip

通过一个主应用，来管理其它应用。设计难度小，方便实践，但是通用度低

:::

自组织模式

:::tip

应用之间是平等的，不存在相互管理的模式。设计难度大，不方便实施，但是通用度高

:::

不管什么模式，都应该有一个注册应用的服务，做一些内容

**应用发现**。让主应用可以寻找到其它应用。

**应用注册**。即提供新的微前端应用，向应用注册表注册的功能。

**第三方应用注册**。即让第三方应用，可以接入到系统中。

**访问权限等相关配置**

![img](/images/6d81800a19d8bc3ef0c002a3a734b01baad345d6.jpeg)

### 设计理念

:::tip

**中心化**：

应用注册表。这个应用注册表拥有每个应用及对应的入口。在前端领域里，入口的直接表现形式可以是路由，又或者对应的应用映射。

**标识化应用**。

我们需要一个标识符来标识不同的应用，以便于在安装、卸载的时候，能寻找到指定的应用。一个简单的模式，就是通过康威定律来命名应用。

**应用生命周期管理**。

**高内聚，低耦合**

:::

### 生命周期

每个应用都拥有自己的生命周期：

| **Load**      | 决定加载哪个应用，并绑定生命周期        |
| ------------- | --------------------------------------- |
| **bootstrap** | 获取静态资源                            |
| **Mount**     | 安装应用，如创建 DOM 节点               |
| **Unload**    | 删除应用的生命周期                      |
| **Unmount**   | 卸载应用，如删除 DOM 节点、取消事件绑定 |



### 如何拆分

| 方式             | 备注                                                         |
| ---------------- | ------------------------------------------------------------ |
| **路由分发式**   | 通过 HTTP 服务器的反向代理功能，来将请求路由到对应的应用上   |
| **前端微服务化** | 在不同的框架之上设计通讯、加载机制，以在一个页面内加载对应的应用 |
| **微应用化**     | 通过软件工程的方式，在部署构建环境中，组合多个独立应用成一个单体应用 |
| **微件化**       | 开发一个新的构建系统，将部分业务功能构建成一个独立的 chunk 代码，使用时只需要远程加载即可 |
| **前端容器化**   | 通过将 iFrame 作为容器，来容纳其它前端应用                   |
| **应用组件化**   | 借助于 Web Components 技术，来构建跨框架的前端应用           |

#### 路由分发式

路由分发式微前端，即通过路由将不同的业务分发到不同的、独立前端应用上。其通常可以通过 HTTP 服务器的反向代理来实现，又或者是应用框架自带的路由来解决。如下图所示：

![img](/images/f7246b600c338744a149dd9c72b0cffcd52aa082.jpeg)

#### 前端微服务化

前端微服务化，是微服务架构在前端的实施，每个前端应用都是完全独立（技术栈、开发、部署、构建独立）、自主运行的，最后通过模块化的方式组合出完整的前端应用。其架构如下图所示：

![img](/images/3c6d55fbb2fb43162d58f678081b502608f7d3b5.jpeg)

采用这种方式意味着，一个页面上同时存在二个及以上的前端应用在运行。而路由分发式方案，则是一个页面只有唯一一个应用

#### 微应用化

微应用化，即在开发时，应用都是以单一、微小应用的形式存在，而在运行时，则通过构建系统合并这些应用，组合成一个新的应用。其架构如下图所示：

![img](/images/caef76094b36acafc644f1055a669b1503e99ce3.jpeg)

微应用化更多的是以软件工程的方式，来完成前端应用的开发，因此又可以称之为组合式集成。对于一个大型的前端应用来说，采用的架构方式，往往会是通过业务作为主目录，而后在业务目录中放置相关的组件，同时拥有一些通用的共享模板。

#### 微件化

微件（widget），指的是一段可以直接嵌入在应用上运行的代码，它由开发人员预先编译好，在加载时不需要再做任何修改或者编译。而微前端下的微件化则指的是，每个业务团队编写自己的业务代码，并将编译好的代码部署（上传或者放置）到指定的服务器上，在运行时，我们只需要加载相应的业务模块即可。对应的，在更新代码的时候，我们只需要更新对应的模块即可。下图便是微件化的架构示意图：

![img](/images/ac6eddc451da81cbb52aa28671d9c6130b2431f4.jpeg)

在非单面应用时代，要实现微件化方案，是一件特别容易的事。从远程加载来对应的 JavaScript 代码，在浏览器上执行，生成对应的组件嵌入到页面的相应部分。对于业务组件也是类似的，提前编写好我们的业务组件，当需要对应的组件时再响应、执行。

#### 前端容器化

**前端容器：iframe**

iframe 作为一个非常 “古老” 的，人人都觉得普通的技术，却一直很管用。它能有效地将另一个网页/单页面应用嵌入到当前页面中，两个页面间的 CSS 和 JavaScript 是相互隔离的——除去 iframe 父子通信部分的代码，它们之间的代码是完全不相互干扰的。iframe 便相当于是创建了一个全新的独立的宿主环境，类似于沙箱隔离，它意味着前端应用之间可以相互独立运行。

**结合 Web Components 构建**

Web Components 是一套不同的技术，允许开发者创建可重用的定制元素（它们的功能封装在代码之外），并且在 Web 应用中使用它们。

![img](/images/b7fd5266d01609248773e02af1b823ffe7cd34f4.jpeg)

**WC 容器化**

目前困扰 Web Components 技术推广的主要因素，在于浏览器的支持程度。在 Chrome 和 Opera 浏览器上，对于 Web Components 支持良好，而对于 Safari、IE、Firefox 浏览器的支持程度，并没有那么理想。

***\*业务拆分\****

与微服务类似，要划分不同的前端边界，不是一件容易的事。就当前而言，以下几种方式是常见的划分微前端的方式：

**按照业务拆分。****按照权限拆分。****按照变更的频率拆分。****按照组织结构拆分**。利用康威定律来进一步拆分前端应用。**跟随后端微服务划分。**实践证明， DDD 与事件风暴是一种颇为有效的后端微前端拆分模式，对于前端来说，它也颇有有效——直接跟踪后端服务。

![img](/images/b21bb051f81986183f3e1d946c5238768ad4e6ed.jpeg)

每个项目都有自己特殊的背景，切分微前端的方式便不一样。即使项目的类型相似，也存在一些细微的差异。

## 其他

### 应用微化架构

应用微化架构，是一种开发时整体，构建时拆分，运行时分离的前端架构模式。即应用微化架构从一份代码中，构建出适用于不同环境的多套目标代码。实现上它是一种：

**构建时拆分架构。****代码删除架构。**以删代码的方式，来形成每个前端应用。**微前端准备式架构。**即，随时可以拆分为多个前端应用。由于它与微应用化的相似性，我们将它与微应用化做一个对比。它与微应用化不同的是，应用微化是在构建时对应用进行拆分，而非在本地模式下对应用拆分。相似的是，它也是基于构建系统的应用拆分方式。

![img](/images/9345d688d43f8794abb7fbdcf7a418f11ad53a3f.jpeg)

可拆分式微前端

即：微应用化，是一个随时可合并式架构。而应用微化，则是一个随时可拆分式架构。

它不仅仅是一个适合于前端的架构模式，也是一适用于后端的架构模式。



### 整洁前端架构

Clean Architecture 是由 Robert C. Martin 在 2012 年提出的架构模式。它具有这么一些特点：框架无关性、可被测试、UI 无关性、数据库无关性、外部机构（agency）无关性。

对于前端架构来说，Clean Architecure 实际上是：Clean Architecture + MVP + 组件化。如下图所示：

考虑到应用的规模，这里以 Angular + TypeScript 作为示例：

![img](/images/b90e7bec54e736d1b0cb10a9b8ef59c7d76269ff.jpeg)

Clean Frontend

这种架构模式特别适合于：组织内即写前端又同后端的团队。它易于映射前后端 API，且可以使用 UseCase 作为防腐层。

没有银弹。不得不提及的是，对于小规模的团队来说，它带来的弊端可能会远远大于好处——带来大量冗余的代码。尽管通过 Angular Schematics 可以通过参数来生成代码，但是这种分层架构地于简单的应用来说，还是过于复杂、难以上手。对于不写测试的项目来说 ，usecase 也不能带来它们所承诺的好处。